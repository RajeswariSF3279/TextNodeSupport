/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "_content/Syncfusion.Blazor/scripts/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundles/sf-lineargauge.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./bundles/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./bundles/sf-lineargauge.js ***!
  \***********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-lineargauge.js */ "./modules/sf-lineargauge.js");
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./modules/sf-lineargauge.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};

window.sfBlazor.LinearGauge = function () {
  'use strict';
  /* eslint-disable @typescript-eslint/member-delimiter-style */

  /* eslint-disable @typescript-eslint/naming-convention */

  /* eslint-disable @typescript-eslint/dot-notation */

  /* eslint-disable max-len */

  /**
   * LinearGauge Blazor introp module
   */

  var SfLinearGauge =
  /** @class */
  function () {
    // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
    function SfLinearGauge(id, element, options, dotnetRef) {
      this.dragMillisecond = 0;
      this.id = id;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.options = options;
      this.element.blazor__instance = this;
    }

    SfLinearGauge.prototype.render = function () {
      this.wireEvents();
    };

    SfLinearGauge.prototype.wireEvents = function () {
      /*! Bind the Event handler */
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchStartEvent, this.gaugeOnMouseDown, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchMoveEvent, this.gaugeOnMouseMove, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchEndEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchCancelEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, 'click', this.gaugeOnMouseClick, this);
      sf.base.EventHandler.add(this.element, 'mouseleave', this.gaugeOnMouseLeave, this);
      window.addEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.gaugeOnResize.bind(this));
    };

    SfLinearGauge.prototype.gaugeOnResize = function () {
      var width;
      var height;

      if (!sf.base.isNullOrUndefined(this.element)) {
        var svgElement = document.getElementById(this.element.id + '_svg');

        if (!sf.base.isNullOrUndefined(svgElement)) {
          svgElement.style.display = 'none';
          var elementRect = this.element.getBoundingClientRect();
          width = elementRect.width;
          height = elementRect.height;
          svgElement.style.removeProperty('display');
        }
      }

      if (this.previousHeight !== height || this.previousWidth !== width) {
        this.previousHeight = height;
        this.previousWidth = width;

        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerResizeEvent', width, height);
        }
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseClick = function (element) {
      var targetId = element.target.id;

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseLeave = function (element) {
      this.dotNetRef.invokeMethodAsync('TriggerMouseLeaveEvent', element.x, element.y);
    };

    SfLinearGauge.prototype.gaugeOnMouseDown = function (element) {
      var targetId = element.target.id;
      var clientX = 0;
      var clientY = 0;

      if (element.type === 'touchstart') {
        element.preventDefault();
        clientX = element['touches'][0].clientX;
        clientY = element['touches'][0].clientY;
      } else {
        clientX = element.pageX;
        clientY = element.pageY;
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = true;
        this.pointerId = targetId;
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (this.enableDragCollection[axisIndex][pointerIndex]) {
          this.dotNetRef.invokeMethodAsync('TriggerDragStart', axisIndex, pointerIndex);
        }
      } else {
        this.dotNetRef.invokeMethodAsync('TriggerMouseDownEvent', clientX, clientY);
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseMove = function (element) {
      var currentDate = new Date();
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var moveClientX = 0;
      var moveClientY = 0;

      if (element.type === 'touchmove') {
        moveClientX = element['touches'][0].clientX;
        moveClientY = element['touches'][0].clientY;
      } else {
        moveClientX = element.clientX;
        moveClientY = element.clientY;
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (this.pointerCheck && (this.dragMillisecond == 0 || Math.abs(currentDate.getMilliseconds() - this.dragMillisecond) > 80) && this.enableDragCollection[axisIndex][pointerIndex]) {
          this.dragMillisecond = currentDate.getMilliseconds();
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'grabbing');
          this.dotNetRef.invokeMethodAsync('TriggerDrag', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top);
        } else if (!this.pointerCheck && this.enableDragCollection[axisIndex][pointerIndex]) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
        }
      } else {
        document.getElementById(this.id + '_svg').setAttribute('cursor', 'auto');
      }

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1 || targetId.indexOf('Range') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        var parentId = targetId.split('_')[0];
        var parentElement = document.getElementById(parentId).getBoundingClientRect();
        var parentEle = {
          Bottom: parentElement['bottom'],
          Height: parentElement['height'],
          Left: parentElement['left'],
          Right: parentElement['right'],
          Top: parentElement['top'],
          Width: parentElement['width'],
          X: parentElement['x'],
          Y: parentElement['y']
        };
        var lineElement = document.getElementById(parentId + '_AxisLine_' + axisIndex).getBoundingClientRect();
        var lineEle = {
          Bottom: lineElement['bottom'],
          Height: lineElement['height'],
          Left: lineElement['left'],
          Right: lineElement['right'],
          Top: lineElement['top'],
          Width: lineElement['width'],
          X: lineElement['x'],
          Y: lineElement['y']
        };
        var tickElement = document.getElementById(parentId + '_MajorTicksLine_' + axisIndex).getBoundingClientRect();
        var tickEle = {
          Bottom: tickElement['bottom'],
          Height: tickElement['height'],
          Left: tickElement['left'],
          Right: tickElement['right'],
          Top: tickElement['top'],
          Width: tickElement['width'],
          X: tickElement['x'],
          Y: tickElement['y']
        };
        var pointElement = document.getElementById(targetId).getBoundingClientRect();
        var pointEle = {
          Bottom: pointElement['bottom'],
          Height: pointElement['height'],
          Left: pointElement['left'],
          Right: pointElement['right'],
          Top: pointElement['top'],
          Width: pointElement['width'],
          X: pointElement['x'],
          Y: pointElement['y']
        };
        var elementId = targetId.split('_')[0];
        var tooltipElement = document.getElementById(elementId + '_Tooltip');

        if (tooltipElement != null) {
          tooltipElement.style.visibility = 'visible';
        }

        this.dotNetRef.invokeMethodAsync('TriggerTooltip', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top, parentEle, lineEle, tickEle, pointEle);
      } else {
        var elementId = targetId.split('_')[0];
        var tooltipElement = document.getElementById(elementId + '_Tooltip');

        if (tooltipElement != null) {
          tooltipElement.style.visibility = 'hidden';
        }
      }
    };

    SfLinearGauge.prototype.gaugeOnMouseEnd = function (element) {
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var clientX = 0;
      var clientY = 0;

      if (element.type === 'touchend') {
        var touchArg = element;
        clientX = touchArg.changedTouches[0].pageX;
        clientY = touchArg.changedTouches[0].pageY;
      } else {
        clientX = element.clientX;
        clientY = element.clientY;
      }

      this.pointerCheck = false;

      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
        this.dragMillisecond = 0;
        this.pointerId = "";
        var svgBounds = this.svgClient(targetId);
        var parentId = targetId.split('_AxisIndex_')[0].split('_')[0];
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);

        if (this.enableDragCollection[axisIndex][pointerIndex]) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
          this.dotNetRef.invokeMethodAsync('TriggerDragEnd', axisIndex, pointerIndex, parentId, targetId, clientX - svgBounds.left, clientY - svgBounds.top);
        }
      } else {
        this.dotNetRef.invokeMethodAsync('TriggerMouseUpEvent', clientX, clientY);
      }
    };

    SfLinearGauge.prototype.svgClient = function (targetId) {
      var svg = document.getElementById(targetId.split('_AxisIndex_')[0] + '_svg');
      return svg.getBoundingClientRect();
    };

    return SfLinearGauge;
  }(); // eslint-disable-next-line @typescript-eslint/no-explicit-any


  var LinearGauge = {
    initialize: function initialize(element, options, dotnetRef, style) {
      var instance = new SfLinearGauge(element.id, element, options, dotnetRef);
      instance.render();

      if (!sf.base.isNullOrUndefined(style)) {
        element.setAttribute('style', style);
      }

      return this.getElementSize(element);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementSize: function getElementSize(element) {
      var elementWidth;
      var elementHeight;

      if (element != null) {
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width;
        elementHeight = elementRect.height;
      }

      return {
        width: elementWidth,
        height: elementHeight,
        isIE: sf.base.Browser.isIE
      };
    },
    setPathAttribute: function setPathAttribute(id, type, path, x, y, orientation) {
      var pathElement = document.getElementById(id);

      if (type === '') {
        pathElement.setAttribute('d', path);
      } else if (type == 'Circle') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('cx', x.toString());
        } else {
          pathElement.setAttribute('cy', y.toString());
        }
      } else if (type == 'Rectangle' || type == 'Image') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('x', x.toString());
        } else {
          pathElement.setAttribute('y', y.toString());
        }
      } else {
        pathElement.setAttribute('x', x.toString());
        pathElement.setAttribute('y', y.toString());
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateCollection: function updateCollection(element, collection) {
      if (element && element.blazor__instance) {
        element.blazor__instance.enableDragCollection = JSON.parse(collection.enableDragCollection);
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementBounds: function getElementBounds(id) {
      var htmlElement = document.getElementById(id);

      if (htmlElement) {
        var bounds = htmlElement.getBoundingClientRect();
        return {
          width: bounds.width,
          height: bounds.height,
          top: bounds.top,
          bottom: bounds.bottom,
          left: bounds.left,
          right: bounds.right
        };
      }

      return null;
    }
  };
  return LinearGauge;
}();

/***/ })

/******/ });